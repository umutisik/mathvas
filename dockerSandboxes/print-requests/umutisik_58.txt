Username: umutisik
Email: umutisik@gmail.com
Snippet Title: NiceRepeat
Snippet Id: 58
Activity: Grayscale
Entered Code: 
-- this is the function that will be drawn 
theFunctionToDraw = tilefs finonum f

finonum = 11

fff1 x y = norma x 
fff2 x y = norma y

tilefs :: Integer -> (Integer -> Integer -> R -> R -> R) -> R -> R -> R
tilefs k f x y =  let fk = fromIntegral k
                      st tt = (floorf ((fk)*(norma tt)))
                      n = round $ (st x)
                      m = round $ (st y)
                      norx = norma x
                      nory = norma y
                      adjustedx = unorma (fk*norx - fromIntegral n) 
                      adjustedy = unorma (fk*nory - fromIntegral m)
                  in f n m adjustedx adjustedy
                  
                  
--f n m x y = (roundints n m)/10
f n m x y = spi (8 + 1.5*(roundints n m)) x y

roundints :: Integer -> Integer -> R
roundints n m =  (sqrt $ (n'^2+m'^2))
                     where fn =(finum/(finum-1)) * fromIntegral n
                           fm =(finum/(finum-1)) * fromIntegral m
                           finum = fromIntegral finonum
                           n' = fn - (finum/2)
                           m' = fm - (finum/2)

circ r x y = if x^2+y^2 < r^2 then 0 else 1                   
                  
                  
                  
spi :: R -> R -> R -> R
spi k x y = if x<0 then ((strip (fst xypair) (snd xypair)))
                   else ((strip (fst xypair) (snd xypair)))
              where xypair = rotate (k*(distanceToOrigin x y )) x y

distanceToOrigin :: R -> R -> R
distanceToOrigin x y = sqrt (x^2+y^2)

strip x y = if ((abs x < 1*y) && y > 0) then 0 else 1

                  
                  
                  
checkers :: R -> R -> R -> R
checkers k x y = let s2 tt = stepso 2 (modulus 1 $ k*(norma tt))
                 in  fmod ((s2 x) + (s2 y)) 2

rotate :: R -> R -> R -> (R,R)
rotate theta x y = let ct = cos theta
                       st = sin theta
                   in (x*ct - y*st, x*st + y*ct)

norma :: R -> R
norma x = (x+1)/2
unorma :: R -> R
unorma y = 2*y-1

(kombin h f g) x y = if h x y > 0.5 then f x y else g x y 

modulus k x = x - (floorf (x/k))*k
steps 1 x = 0 
steps k x = (1/(k-1))*(floorf ((k)*(norma x)))
stepso k x = (1/(k-1))*(floorf ((k)*(x)))
floorf x = fromInteger (floor x)

naivstep k x = (floorf ((k)*(norma x)))

fmod x k = fromInteger $ (floor x) `mod` k




